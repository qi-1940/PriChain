RT 互斥体通过优先级继承协议扩展了简单互斥体的语义。

rt-mutex 的低优先级所有者(owner)继承高优先级等待者(waiter)的优先级，直到 rt-mutex 被释放。 如果临时提升的所有者又被其它 rt-mutex 阻塞，它会将优先级提升继续传播给阻塞它的其他 rt_mutex 的所有者。 一旦 rt_mutex 被释放，优先级提升会立即被移除。

这种方法使我们能够缩短保护共享资源的互斥锁上的高优先级任务块。 优先级继承对于设计不佳的应用程序来说不是灵丹妙药，但它允许设计良好的应用程序在高优先级线程的关键部分使用用户空间锁，而不会失去确定性。

将等待者排队到 rtmutex 等待者树中是按优先顺序完成的。 **对于相同的优先级，选择 FIFO 顺序**。对于每个 rtmutex，只有最高优先级的waiters被排入owner的优先级waiter树中。 这棵树也按优先顺序排队。 每当任务的最高优先级等待者发生变化（例如超时或收到信号）时，owner task的优先级就会被重新调整。 优先级排
队由“pi_waiters”处理

RT-mutexes 针对快速路径操作进行了优化，并且在无竞争时锁定互斥锁或在没有等待者的情况下解锁互斥锁都没有内部开销。 优化的快速路径操作需要 cmpxchg 支
持。
[如果不可用，则使用 rt-mutex 内部自旋锁]

rt-mutex 的状态通过 rt-mutex 结构的 owner 字段进行跟踪：

lock->owner 持有 owner 的 task_struct 指针。 位 0 用于跟踪“锁有等待者”状态：

> ============ ======= ================================================
> 所有者      	       bit0    				    注释
> ============ ======= ================================================
> NULL         		0       				锁是空闲的（可以快速获取）
> NULL        		 1       				锁是空闲的，有等待者，top waiter要拿锁[1]_
> taskpointer  	    0      			         锁被持有（可以快速释放）
> taskpointer   	   1       			        锁被持有并且有等待者 [2]_
> ============ ======= ================================================

只有当 lock->owner 的 bit 0 为 0 时，基于快速原子比较交换的获取和释放才有可能。

.. [1] 当持有 ->wait_lock 的状态下获取锁时，它也可能是一个过渡状态。 为了防止 cmpxchg 到锁的任何快速路径，我们需要在查看锁之前设置 bit0，并且所有
者在这段时间内可能为 NULL，因此这可以是一个过渡状态。

.. [2] 位 0 被设置但没有waiters的时间是很短的。 在慢速路径上抢锁时可能会发生这种情况。 为了防止所有者的 cmpxchg 释放锁，我们需要在查看锁之前设置该位。

顺便说一句，技术上仍然有一个“Pending Owner”，只是不再那样称呼了。 pending owner恰好是一个没有owner的锁的top_waiter，已经被唤醒去抢锁。

https://blog.csdn.net/cxjczy1990/article/details/143382660